// Generated by CoffeeScript 2.6.1
// UnitTester.coffee
import test from 'ava';

import {
  assert,
  undef,
  pass,
  error,
  croak,
  isString,
  isFunction,
  isInteger,
  isArray
} from '@jdeighan/coffee-utils';

import {
  log,
  setLogger
} from '@jdeighan/coffee-utils/log';

import {
  debug,
  debugging,
  setDebugging
} from '@jdeighan/coffee-utils/debug';

import {
  normalize,
  super_normalize
} from '@jdeighan/unit-tester/utils';

// ---------------------------------------------------------------------------
export var UnitTester = class UnitTester {
  constructor(source = undef) {
    var avaName, i, len, myName, ref, testDesc;
    this.source = source;
    this.hFound = {}; // used line numbers
    this.whichTest = 'deepEqual';
    ref = ['truthy', 'falsy', ['same', 'is'], ['different', 'not']];
    // --- We already have tests named:
    //        'equal', 'notequal', 'fails', 'succeeds'
    //     Add 4 more:
    for (i = 0, len = ref.length; i < len; i++) {
      testDesc = ref[i];
      if (isArray(testDesc)) {
        [myName, avaName] = testDesc;
      } else {
        myName = avaName = testDesc;
      }
      this.addTest(myName, function(lineNum, input, expected = undef) {
        this.whichTest = avaName;
        this.test(lineNum, input, expected);
      });
    }
  }

  // ........................................................................
  addTest(name, func) {
    this[name] = func;
  }

  // ........................................................................
  test(lineNum, input, expected) {
    var doDebug, err, errMsg, got, ident, testLineNum, whichTest;
    if (isString(lineNum)) {
      lineNum = parseInt(lineNum, 10);
    }
    assert(isInteger(lineNum) && (lineNum > 0), "UnitTester.test(): arg 1 must be a positive integer");
    testLineNum = parseInt(process.env.UNIT_TEST_LINENUM, 10);
    doDebug = process.env.UNIT_TEST_DEBUG;
    if (doDebug) {
      console.log(`UNIT_TEST_LINENUM = ${testLineNum}`);
    }
    if (testLineNum) {
      if (lineNum === testLineNum) {
        if (doDebug) {
          console.log(`CUR_LINE_NUM = ${lineNum} - testing`);
        }
      } else {
        if (doDebug) {
          console.log(`CUR_LINE_NUM = ${lineNum} - skipping`);
        }
        return;
      }
    }
    this.initialize();
    this.lineNum = lineNum; // set an property, for error reporting
    errMsg = undef;
    try {
      got = this.normalize(this.transformValue(input));
    } catch (error1) {
      err = error1;
      errMsg = err.message || 'UNKNOWN ERROR';
      log(`got ERROR in unit test: ${errMsg}`);
    }
    expected = this.normalize(this.transformExpected(expected));
    if (process.env.UNIT_TEST_JUST_SHOW) {
      log(`line ${this.lineNum}`);
      if (errMsg) {
        log(`GOT ERROR ${errMsg}`);
      } else {
        log(got, "GOT:");
      }
      log(expected, "EXPECTED:");
      return;
    }
    // --- We need to save this here because in the tests themselves,
    //     'this' won't be correct
    whichTest = this.whichTest;
    // --- test names must be unique, getLineNum() ensures that
    lineNum = this.getLineNum(lineNum);
    ident = `line ${lineNum}`;
    if (this.source) {
      ident += ` in ${this.source}`;
    }
    test(ident, function(t) {
      return t[whichTest](got, expected);
    });
  }

  // ........................................................................
  initialize() { // override to do any initialization
    return pass;
  }

  // ........................................................................
  getLineNum(lineNum) {
    // --- patch lineNum to avoid duplicates
    while (this.hFound[lineNum]) {
      lineNum += 1000;
    }
    this.hFound[lineNum] = true;
    return lineNum;
  }

  // ........................................................................
  transformValue(input) {
    return input;
  }

  // ........................................................................
  transformExpected(input) {
    return input;
  }

  // ........................................................................
  // may override, e.g. to remove comments
  isEmptyLine(line) {
    return line === '';
  }

  // ........................................................................
  normalize(text) {
    return text;
  }

  // ........................................................................
  equal(lineNum, input, expected) {
    this.whichTest = 'deepEqual';
    this.test(lineNum, input, expected);
  }

  // ........................................................................
  notequal(lineNum, input, expected) {
    this.whichTest = 'notDeepEqual';
    this.test(lineNum, input, expected);
  }

  // ........................................................................
  fails(lineNum, func, expected) {
    var err, logger, ok;
    assert(expected == null, "UnitTester: fails doesn't allow expected");
    assert(isFunction(func), "UnitTester: fails requires a function");
    // --- disable logging
    logger = setLogger(function(x) {
      return pass;
    });
    try {
      func();
      ok = true;
    } catch (error1) {
      err = error1;
      ok = false;
    }
    setLogger(logger);
    this.whichTest = 'falsy';
    this.test(lineNum, ok, expected);
  }

  // ........................................................................
  succeeds(lineNum, func, expected) {
    var err, ok;
    assert(expected == null, "UnitTester: succeeds doesn't allow expected");
    assert(isFunction(func), "UnitTester: succeeds requires a function");
    try {
      func();
      ok = true;
    } catch (error1) {
      err = error1;
      ok = false;
    }
    this.whichTest = 'truthy';
    this.test(lineNum, ok, expected);
  }

};

// ---------------------------------------------------------------------------
export var UnitTesterNorm = class UnitTesterNorm extends UnitTester {
  normalize(text) {
    return normalize(text);
  }

};

// ---------------------------------------------------------------------------
export var UnitTesterSuperNorm = class UnitTesterSuperNorm extends UnitTester {
  normalize(text) {
    return super_normalize(text);
  }

};
